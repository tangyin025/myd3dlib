/*
Copyright (c) 2010, Pierre KRIEGER
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef INCLUDE_LUA_LUACONTEXT_H
#define INCLUDE_LUA_LUACONTEXT_H

#include <algorithm>
#include <cassert>
#include <cstring>
#include <functional>
#include <limits>
#include <map>
#include <memory>
#include <tuple>
#include <type_traits>
#include <string>
#include <sstream>

extern "C" {
#	include <lua5.1/lua.h>
#	include <lua5.1/lualib.h>
#	include <lua5.1/lauxlib.h>
}

#if defined(__GNUC__) && __GNUC__ <= 4 && __GNUC_MINOR__ <= 5
#	define nullptr		0
#endif

#if !defined(_MSC_VER) || _MSC_VER >= 1700
#	include <thread>
#else
#	include <boost/thread.hpp>
#	include <boost/thread/locks.hpp>
#	include <boost/thread/mutex.hpp>
#	include <boost/type_traits.hpp>
	namespace std {
		using ::boost::thread;
		using ::boost::mutex;
		using ::boost::recursive_mutex;
		using ::boost::lock_guard;
		using ::boost::unique_lock;
	}
#endif

namespace Lua {
	/**	\brief Defines a Lua context
		\details A Lua context is used to interpret Lua code. Since everything in Lua is a variable (including functions),
				we only provide few functions like readVariable and writeVariable. Note that these functions can visit arrays,
				ie. calling readVariable("a.b.c") will read variable "c" from array "b", which is itself located in array "a".

				You can also write variables with C++ functions so that they are callable by Lua. Note however that you HAVE TO convert
				your function to std::function (not directly std::bind or a lambda function) so the class can detect which argument types
				it wants. These arguments may only be of basic types (int, float, etc.) or std::string.
	*/
	class LuaContext {
	public:
		 LuaContext();
		 LuaContext(LuaContext&& s) : _state(s._state) { s._state = nullptr; }
		 LuaContext& operator=(LuaContext&& s) { std::swap(_state, s._state); return *this; }
		~LuaContext()							{ if (_state != nullptr) lua_close(_state); }
		

		/// \brief Thrown when an error happens during execution (like not enough parameters for a function)
		class ExecutionErrorException : public std::runtime_error { public: ExecutionErrorException(const std::string& msg) : std::runtime_error(msg.c_str()) {} };
		/// \brief Generated by readVariable or isVariableArray when the asked variable doesn't exist/is nil
		class VariableDoesntExistException : public std::runtime_error { public: VariableDoesntExistException(const std::string& variable) : std::runtime_error((std::string("Variable \"") + variable + std::string("\" doesn't exist in lua context")).c_str()) {} };
		/// \brief Thrown when a syntax error happens in a lua script
		class SyntaxErrorException : public std::runtime_error { public: SyntaxErrorException(const std::string& msg) : std::runtime_error(msg.c_str()) {} };
		/// \brief Thrown when trying to cast a lua variable to an unvalid type
		class WrongTypeException : public std::runtime_error { public: WrongTypeException() : std::runtime_error("Trying to cast a lua variable to an unvalid type") { } };

		
		/// \brief Executes lua code from the stream \param code A stream that lua will read its code from
		void				executeCode(std::istream& code);
		/// \brief Executes lua code given as parameter \param code A string containing code that will be executed by lua
		void				executeCode(const std::string& code)			{ std::istringstream str(code); executeCode(str); }
		

		/// \brief Tells that lua will be allowed to access an object's function
		template<typename T>
		void				registerFunction(const std::string& name, void (T::*f)())				{ _registerFunction(name, [f](std::shared_ptr<T> ptr) { ((*ptr).*f)(); }); }
		template<typename T, typename R>
		void				registerFunction(const std::string& name, R (T::*f)())					{ _registerFunction(name, [f](std::shared_ptr<T> ptr) { return ((*ptr).*f)(); }); }
		template<typename T, typename P1>
		void				registerFunction(const std::string& name, void (T::*f)(P1))				{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1) { ((*ptr).*f)(p1); }); }
		template<typename T, typename R, typename P1>
		void				registerFunction(const std::string& name, R (T::*f)(P1))					{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1) { return ((*ptr).*f)(p1); }); }
		template<typename T, typename P1, typename P2>
		void				registerFunction(const std::string& name, void (T::*f)(P1,P2))				{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2) { ((*ptr).*f)(p1,p2); }); }
		template<typename T, typename R, typename P1, typename P2>
		void				registerFunction(const std::string& name, R (T::*f)(P1,P2))					{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2) { return ((*ptr).*f)(p1,p2); }); }
		template<typename T, typename P1, typename P2, typename P3>
		void				registerFunction(const std::string& name, void (T::*f)(P1,P2,P3))				{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2, P3 p3) { ((*ptr).*f)(p1,p2,p3); }); }
		template<typename T, typename R, typename P1, typename P2, typename P3>
		void				registerFunction(const std::string& name, R (T::*f)(P1,P2,P3))					{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2, P3 p3) { return ((*ptr).*f)(p1,p2,p3); }); }
		template<typename T, typename P1, typename P2, typename P3, typename P4>
		void				registerFunction(const std::string& name, void (T::*f)(P1,P2,P3,P4))				{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2, P3 p3, P4 p4) { ((*ptr).*f)(p1,p2,p3,p4); }); }
		template<typename T, typename R, typename P1, typename P2, typename P3, typename P4>
		void				registerFunction(const std::string& name, R (T::*f)(P1,P2,P3,P4))					{ _registerFunction(name, [f](std::shared_ptr<T> ptr, P1 p1, P2 p2, P3 p3, P4 p4) { return ((*ptr).*f)(p1,p2,p3,p4); }); }

		/// \brief Adds a custom function to a type determined using the function's first parameter
		/// \sa allowFunction
		/// \param fn Function which takes as first parameter a std::shared_ptr
		template<typename T>
		void				registerFunction(const std::string& name, T fn, size_t x = sizeof(decltype(&T::operator())))				{ _registerFunction(name, fn); }

		/// \brief Inverse operation of registerFunction
		template<typename T>
		void				unregisterFunction(const std::string& name)										{ _unregisterFunction<T>(name); }

		/// \brief Calls a function stored in a lua variable
		/// \details Template parameter of the function should be the expected return type (tuples and void are supported)
		/// \param variableName Name of the variable containing the function to call
		/// \param ... Parameters to pass to the function
		template<typename R>
		R callLuaFunction(const std::string& variableName) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::tuple<>());
		}
		template<typename R, typename T1>
		R callLuaFunction(const std::string& variableName, const T1& t1) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1));
		}
		template<typename R, typename T1, typename T2>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2));
		}
		template<typename R, typename T1, typename T2, typename T3>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4,t5));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4,t5,t6));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4,t5,t6,t7));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4,t5,t6,t7,t8));
		}
		template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
		R callLuaFunction(const std::string& variableName, const T1& t1, const T2& t2, const T3& t3, const T4& t4, const T5& t5, const T6& t6, const T7& t7, const T8& t8, const T9& t9) {
			std::lock_guard<std::mutex> stateLock(_stateMutex);
			_getGlobal(variableName);
			return _call<R>(std::make_tuple(t1,t2,t3,t4,t5,t6,t7,t8,t9));
		}
		

		/// \brief Returns true if the value of the variable is an array \param variableName Name of the variable to check
		bool							isVariableArray(const std::string& variableName) const;
		/// \brief Writes an empty array into the given variable \note To write something in the array, use writeVariable. Example: writeArrayIntoVariable("myArr"); writeVariable("myArr.something", 5);
		void							writeArrayIntoVariable(const std::string& variableName);

		/// \brief Returns true if variable exists (ie. not nil)
		bool							doesVariableExist(const std::string& variableName) const			{ std::lock_guard<std::mutex> lock(_stateMutex); _getGlobal(variableName); bool answer = lua_isnil(_state, -1); lua_pop(_state, 1); return answer; }

		/// \brief Destroys a variable \details Puts the nil value into it
		void							clearVariable(const std::string& variableName)							{ std::lock_guard<std::mutex> lock(_stateMutex); lua_pushnil(_state); _setGlobal(variableName); }
		
		/// \brief Returns the content of a variable \throw VariableDoesntExistException if variable doesn't exist \note If you wrote a ObjectWrapper<T> into a variable, you can only read its value using a std::shared_ptr<T>
		template<typename T> T			readVariable(const std::string& variableName) const				{ std::lock_guard<std::mutex> lock(_stateMutex); _getGlobal(variableName); return _read(-1, (T*)nullptr); }

		/// \brief Changes the content of a global lua variable
		/// \details Accepted values are: all base types (integers, floats), std::string, std::function or ObjectWrapper<...>. All objects are passed by copy and destroyed by the garbage collector.
		template<typename T> void writeVariable(const std::string& variableName, T&& data) {
			static_assert(!std::is_same<typename Tupleizer<T>::type,T>::value, "Error: you can't use LuaContext::writeVariable with a tuple");
			std::lock_guard<std::mutex> lock(_stateMutex);
			int pushedElems = _push(std::forward<T>(data));
			_setGlobal(variableName);
			lua_pop(_state, pushedElems - 1);
		}



	private:
		// forbidding copy
		LuaContext(const LuaContext&);
		LuaContext& operator=(const LuaContext&);


		// the state is the most important variable in the class since it is our interface with Lua
		// the mutex is here because the lua design is not thread safe (based on a stack)
		//   eg. if multiple thread call "writeVariable" at the same time, we don't want them to be executed simultaneously
		// the mutex should be locked by all public functions that use the stack
		lua_State*					_state;
		mutable std::mutex			_stateMutex;
		
		// all the user types in the _state must have the value of typeid(T).name() in their
		//   metatable at key "_typeid"

		// the getGlobal function is equivalent to lua_getglobal, except that it can interpret
		//   any variable name in a table form (ie. names like table.value are supported)
		// see also http://www.lua.org/manual/5.1/manual.html#lua_getglobal
		// same for setGlobal <=> lua_setglobal
		// important: _setGlobal will pop the value even if it throws an exception, while _getGlobal won't push the value if it throws an exception
		void _getGlobal(const std::string& variable) const;
		void _setGlobal(const std::string& variable);

		// simple function that reads the top # elements of the stack, pops them, and returns them
		// warning: first parameter is the number of parameters, not the parameter index
		// if _read generates an exception, stack is poped anyway
		template<typename R>
		R _readTopAndPop(int nb, R* ptr = nullptr, typename std::enable_if<!std::is_void<R>::value>::type* = nullptr) {
			try {
				R value = _read(-nb, ptr);
				lua_pop(_state, nb);
				return value;
			} catch(...) {
				lua_pop(_state, nb);
				throw;
			}
		}
		void _readTopAndPop(int nb, void* ptr = nullptr) {
			lua_pop(_state, nb);
		}
		

		/**************************************************/
		/*            FUNCTIONS REGISTRATION              */
		/**************************************************/
		// the "registerFunction" public functions call this one
		// this function writes in registry the list of functions for each possible custom type (ie. T when pushing std::shared_ptr<T>)
		// to be clear, registry[typeid(T).name()] contains an array where keys are function names and values are functions
		template<typename T> void _registerFunction(const std::string& name, T function) {
			typedef typename RemoveMemberPtr<decltype(&T::operator())>::type													FunctionType;
			typedef typename std::tuple_element<0,typename FnTupleWrapper<FunctionType>::ParamsType>::type::element_type		ObjectType;
			static const char* objectTypeName = typeid(ObjectType).name();

			// trying to get the existing functions list
			lua_pushstring(_state, objectTypeName);
			lua_gettable(_state, LUA_REGISTRYINDEX);

			// if it doesn't exist, we create one, then write it in registry but keep it pushed
			if (!lua_istable(_state, -1)) {
				assert(lua_isnil(_state, -1));
				lua_pop(_state, 1);
				lua_newtable(_state);
				lua_pushstring(_state, objectTypeName);
				lua_pushvalue(_state, -2);
				lua_settable(_state, LUA_REGISTRYINDEX);
			}

			// now we have our functions list on top of the stack, we write the function here
			lua_pushstring(_state, name.c_str());
			_push(std::move(function));
			lua_settable(_state, -3);

			lua_pop(_state, -1);
		}

		// inverse operation of _registerFunction
		template<typename T> void _unregisterFunction(const std::string& name) {
			static const char* typeName = typeid(T).name();

			// trying to get the existing functions list
			lua_pushstring(_state, typeName);
			lua_gettable(_state, LUA_REGISTRYINDEX);
			if (!lua_istable(_state, -1))	{ lua_pop(_state, -1); return; }
			lua_pushstring(_state, name.c_str());
			lua_pushnil(_state);
			lua_settable(_state, -3);
			lua_pop(_state, -1);
		}
		

		/**************************************************/
		/*              LOADING AND CALLING               */
		/**************************************************/
		// this function calls what is on the top of the stack and removes it (just like lua_call)
		// if an exception is triggered, the top of the stack will be removed anyway
		// In should be a tuple, Out can be anything
		template<typename Out, typename In>
		Out _call(const In& in) {
			static_assert(std::tuple_size<In>::value >= 0, "Error: template parameter 'In' should be a tuple");

			int outArguments = 0;
			int inArguments = 0;
			try {
				// we push the parameters on the stack
				outArguments = std::tuple_size<typename Tupleizer<Out>::type>::value;
				inArguments = _push(in);
			} catch(...) { lua_pop(_state, 1); throw; }

			// calling pcall automatically pops the parameters and pushes output
			auto pcallReturnValue = lua_pcall(_state, inArguments, outArguments, 0);

			// if pcall failed, analyzing the problem and throwing
			if (pcallReturnValue != 0) {
				// an error occured during execution, an error message was pushed on the stack
				std::string errorMsg = _readTopAndPop(1, (std::string*)nullptr);
				if (pcallReturnValue == LUA_ERRMEM)			throw(std::bad_alloc());
				else if (pcallReturnValue == LUA_ERRRUN)	throw(ExecutionErrorException(errorMsg));
			}

			// pcall succeeded, we pop the returned values and return them
			try { return _readTopAndPop(outArguments, (Out*)nullptr);
			} catch(...) { lua_pop(_state, outArguments); throw; }
		}


		/**************************************************/
		/*                PUSH FUNCTIONS                  */
		/**************************************************/
		// first the basic ones: integer, number, boolean, string
		int _push()							{ return 0; }
		int _push(lua_Integer v)			{ lua_pushinteger(_state, v); return 1; }
		int _push(lua_Number v)				{ lua_pushnumber(_state, v); return 1; }
		int _push(bool v)					{ lua_pushboolean(_state, v); return 1; }
		int _push(const std::string& s)		{ lua_pushstring(_state, s.c_str()); return 1; }
		int _push(const char* s)			{ lua_pushstring(_state, s); return 1; }

		// using variadic templates, you can push multiple values at once
		/*template<typename T1, typename T2, typename... Args>
		int _push(const T1& v1, const T2& v2, const Args& ...args) {
			int p = _push(v1);
			try { p += _push(v2, args);
			} catch(...) { lua_pop(_state, p); throw; }
			return p;
		}
		*/

		// pushing tuples is also possible
		// TODO: won't work until C++0x, and even after I'm not sure that constexpr ints can be passed as template parameter
		/*template<typename T>
		int _push(const T& t, constexpr int n = std::tuple_size<T>::value) {
			int p = _push(t, n-1);
			try { p += _push(std::get<n-1>(t));
			} catch(...) { lua_pop(_state, p); throw; }
			return p;
		}*/

		// when you push a std::function<int (lua_State*)> it pushes a callable object
		// when this object is called, the function is directly executed and should behave like a traditional lua callback
		// this function's definition is in the .cpp
		int _push(std::function<int (lua_State*)> fn);

		// when you call _push with a functor, this definition should be used (thanks to SFINAE)
		// it will determine the function category thanks to its () operator, then
		//   generate a corresponding std::function<int (lua_State*)> and push it
		template<typename T>
		int _push(T fn, size_t x = sizeof(decltype(&T::operator()))) {
			typedef typename RemoveMemberPtr<decltype(&T::operator())>::type		FnType;

			return _push(std::function<int (lua_State*)>([this,fn](lua_State* state) -> int {
				// FnTupleWrapper<FnType> is a specialized template structure which defines
				// "ParamsType", "ReturnType" and "call"
				// the first two correspond to the params list and return type as tuples
				//   and "call" is a static function which will call a function of this type using parameters passed as a tuple
				typedef	LuaContext::FnTupleWrapper<FnType>		TupledFunction;
					
				// checking if number of parameters is correct
				int paramsCount = std::tuple_size<typename TupledFunction::ParamsType>::value;
				if (lua_gettop(state) < paramsCount) {
					// if not, using lua_error to return an error
					luaL_where(state, 1);
					lua_pushstring(state, "this function requires at least ");
					lua_pushnumber(state, paramsCount);
					lua_pushstring(state, " parameter(s)");
					lua_concat(state, 4);

					// lua_error throws an exception when compiling as C++
					return lua_error(state);
				}
				
				// reading parameters from the stack using the TupleReader utility
#				ifdef _MSC_VER
					auto parameters = this->_read(-paramsCount, (TupledFunction::ParamsType*)nullptr);
#				else
					auto parameters = this->_read(-paramsCount, (typename TupledFunction::ParamsType*)nullptr);
#				endif
				// calling the function, note that "result" should be a tuple
				auto result = TupledFunction::call(fn, parameters);
				// pushing the result on the stack
				return this->_push(result);
			}));
		}

		// when pushing a unique_ptr, it is simply converted to a shared_ptr
		// this definition is necessary because unique_ptr has an implicit bool conversion operator
		// with C++0x, this bool operator will certainly be declared explicit
		template<typename T>
		int _push(std::unique_ptr<T> obj) {
			return _push(std::shared_ptr<T>(std::move(obj)));
		}

		// when pushing a shared_ptr, we create a custom type
		// we store a copy of the shared_ptr inside lua's internals
		//   and add it a metatable: __gc for destruction and __index pointing to the corresponding
		//   table in the registry (see _registerFunction)
		template<typename T>
		int _push(std::shared_ptr<T> obj) {
			// this is a structure providing static C-like functions that we can feed to lua
			struct Callback {
				// this function is called when lua's garbage collector no longer needs our shared_ptr
				// we simply call its destructor
				static int garbage(lua_State* lua) {
					assert(lua_gettop(lua) == 1);
					std::shared_ptr<T>* ptr = (std::shared_ptr<T>*)lua_touserdata(lua, 1);
					assert(ptr);
					assert(*ptr);
					ptr->~shared_ptr();
					return 0;
				}
			};

			// creating the object
			// lua_newuserdata allocates memory in the internals of the lua library and returns it so we can fill it
			//   and that's what we do with placement-new
			std::shared_ptr<T>* pointerLocation = (std::shared_ptr<T>*)lua_newuserdata(_state, sizeof(std::shared_ptr<T>));
			try {
				new (pointerLocation) std::shared_ptr<T>(std::move(obj));

				// creating the metatable (over the object on the stack)
				// lua_settable pops the key and value we just pushed, so stack management is easy
				// all that remains on the stack after these function calls is the metatable
				lua_newtable(_state);
				try {
					// using the garbage collecting function we created above
					lua_pushstring(_state, "__gc");
					lua_pushcfunction(_state, &Callback::garbage);
					lua_settable(_state, -3);

					// settings typeid of shared_ptr this time
					lua_pushstring(_state, "_typeid");
					lua_pushstring(_state, typeid(std::shared_ptr<T>).name());
					lua_settable(_state, -3);

					// as __index we set the table located in registry at type name
					// see comments at _registerFunction
					lua_pushstring(_state, "__index");
					lua_pushstring(_state, typeid(T).name());
					lua_gettable(_state, LUA_REGISTRYINDEX);
					if (!lua_istable(_state, -1)) {
						assert(lua_isnil(_state, -1));
						lua_pop(_state, 1);
						lua_newtable(_state);
						lua_pushstring(_state, typeid(T).name());
						lua_pushvalue(_state, -2);
						lua_settable(_state, LUA_REGISTRYINDEX);
					}
					lua_settable(_state, -3);
					
					// at this point, the stack contains the object at offset -2 and the metatable at offset -1
					// lua_setmetatable will bind the two together and pop the metatable
					// our custom type remains on the stack (and that's what we want since this is a push function)
					lua_setmetatable(_state, -2);

				} catch(...) { lua_pop(_state, 1); throw; }
			} catch(...) { lua_pop(_state, 1); throw; }

			return 1;
		}

		// functions that allow you to push tuples
		int _push(std::tuple<>) {
			return 0;
		}
		template<typename T1>
		int _push(const std::tuple<T1>& t) {
			return _push(std::get<0>(t));
		}
		template<typename T1, typename T2>
		int _push(const std::tuple<T1,T2>& t) {
			int p = _push(std::get<0>(t));
			p += _push(std::get<1>(t));
			return p;
		}
		template<typename T1, typename T2, typename T3>
		int _push(const std::tuple<T1,T2,T3>& t) {
			int p = _push(std::get<0>(t));
			p += _push(std::get<1>(t));
			p += _push(std::get<2>(t));
			return p;
		}
		template<typename T1, typename T2, typename T3, typename T4>
		int _push(const std::tuple<T1,T2,T3,T4>& t) {
			int p = _push(std::get<0>(t));
			p += _push(std::get<1>(t));
			p += _push(std::get<2>(t));
			p += _push(std::get<3>(t));
			return p;
		}
		template<typename T1, typename T2, typename T3, typename T4, typename T5>
		int _push(const std::tuple<T1,T2,T3,T4,T5>& t) {
			int p = _push(std::get<0>(t));
			p += _push(std::get<1>(t));
			p += _push(std::get<2>(t));
			p += _push(std::get<3>(t));
			p += _push(std::get<4>(t));
			return p;
		}
		template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		int _push(const std::tuple<T1,T2,T3,T4,T5,T6>& t) {
			int p = _push(std::get<0>(t));
			p += _push(std::get<1>(t));
			p += _push(std::get<2>(t));
			p += _push(std::get<3>(t));
			p += _push(std::get<4>(t));
			p += _push(std::get<5>(t));
			return p;
		}

		

		/**************************************************/
		/*                READ FUNCTIONS                  */
		/**************************************************/
		// to use the _read function, pass as second parameter a null pointer whose base type is the wanted return type
		// eg. if you want an int, pass "(int*)nullptr" as second parameter

		// reading void
		void _read(int index, void* = nullptr) const {
		}

		// first the integer types
		template<typename T>
		T _read(int index, T* = nullptr, typename std::enable_if<std::numeric_limits<T>::is_integer>::type* = nullptr) const {
			if (lua_isuserdata(_state, index))
				throw(WrongTypeException());
			return T(lua_tointeger(_state, index));
		}

		// then the floating types
		template<typename T>
		T _read(int index, T* = nullptr, typename std::enable_if<std::numeric_limits<T>::is_specialized && !std::numeric_limits<T>::is_integer>::type* = nullptr) const {
			if (lua_isuserdata(_state, index))
				throw(WrongTypeException());
			return T(lua_tonumber(_state, index));
		}

		// boolean
		bool _read(int index, bool* = nullptr) const {
			if (lua_isuserdata(_state, index))
				throw(WrongTypeException());
			return lua_toboolean(_state, index) != 0;		// "!= 0" removes a warning because lua_toboolean returns an int
		}

		// the string implementation is the easiest
		// lua_tostring returns a temporary pointer, but that's not a problem since we copy
		//   the data in a std::string
		std::string _read(int index, std::string* = nullptr) const {
			if (lua_isuserdata(_state, index))
				throw(WrongTypeException());
			return lua_tostring(_state, index);
		}

		// reading a shared_ptr
		// we check that type is correct by reading the metatable
		template<typename T>
		std::shared_ptr<T> _read(int index, std::shared_ptr<T>* = nullptr) const {
			if (!lua_isuserdata(_state, index))		throw(WrongTypeException());
			if (!lua_getmetatable(_state, index))	throw(WrongTypeException());

			// now we have our metatable on the top of the stack
			// retrieving its _typeid member
			lua_pushstring(_state, "_typeid");
			lua_gettable(_state, -2);
			// if wrong typeid, we throw
			if (strcmp(lua_tostring(_state, -1), typeid(std::shared_ptr<T>).name())) {
				lua_pop(_state, 2);
				throw(WrongTypeException());
			}
			lua_pop(_state, 2);

			// now we know that the type is correct, we retrieve the pointer
			const auto ptr = ((std::shared_ptr<T>*)lua_touserdata(_state, index));
			assert(ptr); assert(*ptr);
			return *ptr;		// returning a copy
		}

		// reading a tuple
		std::tuple<> _read(int index, std::tuple<>* = nullptr) const {
			return std::tuple<>();
		}
		template<typename T1>
		std::tuple<T1> _read(int index, std::tuple<T1>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr));
		}
		template<typename T1, typename T2>
		std::tuple<T1,T2> _read(int index, std::tuple<T1,T2>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr), _read(index+1, (T2*)nullptr));
		}
		template<typename T1, typename T2, typename T3>
		std::tuple<T1,T2,T3> _read(int index, std::tuple<T1,T2,T3>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr), _read(index+1, (T2*)nullptr), _read(index+2, (T3*)nullptr));
		}
		template<typename T1, typename T2, typename T3, typename T4>
		std::tuple<T1,T2,T3,T4> _read(int index, std::tuple<T1,T2,T3,T4>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr), _read(index+1, (T2*)nullptr), _read(index+2, (T3*)nullptr), _read(index+3, (T4*)nullptr));
		}
		template<typename T1, typename T2, typename T3, typename T4, typename T5>
		std::tuple<T1,T2,T3,T4,T5> _read(int index, std::tuple<T1,T2,T3,T4,T5>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr), _read(index+1, (T2*)nullptr), _read(index+2, (T3*)nullptr), _read(index+3, (T4*)nullptr), _read(index+4, (T5*)nullptr));
		}
		template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
		std::tuple<T1,T2,T3,T4,T5,T6> _read(int index, std::tuple<T1,T2,T3,T4,T5,T6>* = nullptr) const {
			return std::make_tuple(_read(index, (T1*)nullptr), _read(index+1, (T2*)nullptr), _read(index+2, (T3*)nullptr), _read(index+3, (T4*)nullptr), _read(index+4, (T5*)nullptr), _read(index+5, (T6*)nullptr));
		}



		/**************************************************/
		/*                   UTILITIES                    */
		/**************************************************/
		template<typename FnType> struct FnTupleWrapper;
		template<typename T> struct Tupleizer;
		template<typename Fn> struct RemoveMemberPtr;
	};


	// this structure takes a function definition as template parameter and defines three things:
	// a ParamsType type which converts the function parameters into a tuple,
	// a ReturnType type which is either std::tuple<> (if void) or std::tuple<original return type>
	// a call function which calls the function using a tuple of type ParamsType, and returns ReturnType
	// this class only supports functions with up to 9 parameters, if you want more either add it yourself or wait for variadic templates
	template<typename FnType>
	struct LuaContext::FnTupleWrapper		{ };
	template<>
	struct LuaContext::FnTupleWrapper<void ()> {
		typedef std::tuple<>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void ()> fn, const ParamsType& params)		{ fn(); return ReturnType(); }
	};
	template<typename R>
	struct LuaContext::FnTupleWrapper<R ()> {
		typedef std::tuple<>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R ()> fn, const ParamsType& params)		{ return ReturnType(fn()); }
	};
	template<typename T1>
	struct LuaContext::FnTupleWrapper<void (T1)> {
		typedef typename LuaContext::Tupleizer<T1>::type	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1)> fn, const ParamsType& params)	{ fn(std::get<0>(params)); return ReturnType(); }
	};
	template<typename R, typename T1>
	struct LuaContext::FnTupleWrapper<R (T1)> {
		typedef typename LuaContext::Tupleizer<T1>::type	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params))); }
	};
	template<typename T1, typename T2>
	struct LuaContext::FnTupleWrapper<void (T1,T2)> {
		typedef std::tuple<T1,T2>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2>
	struct LuaContext::FnTupleWrapper<R (T1,T2)> {
		typedef std::tuple<T1,T2>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params))); }
	};
	template<typename T1, typename T2, typename T3>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3)> {
		typedef std::tuple<T1,T2,T3>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3)> {
		typedef std::tuple<T1,T2,T3>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4)> {
		typedef std::tuple<T1,T2,T3,T4>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4)> {
		typedef std::tuple<T1,T2,T3,T4>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4, typename T5>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4,T5)> {
		typedef std::tuple<T1,T2,T3,T4,T5>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4,T5)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4,T5)> {
		typedef std::tuple<T1,T2,T3,T4,T5>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4,T5)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4,T5,T6)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4,T5,T6)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4,T5,T6)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4,T5,T6)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4,T5,T6,T7)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4,T5,T6,T7)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4,T5,T6,T7)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4,T5,T6,T7)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4,T5,T6,T7,T8)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4,T5,T6,T7,T8)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params), std::get<7>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4,T5,T6,T7,T8)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4,T5,T6,T7,T8)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params), std::get<7>(params))); }
	};
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	struct LuaContext::FnTupleWrapper<void (T1,T2,T3,T4,T5,T6,T7,T8,T9)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9>	ParamsType;
		typedef std::tuple<>	ReturnType;
		static ReturnType call(std::function<void (T1,T2,T3,T4,T5,T6,T7,T8,T9)> fn, const ParamsType& params)	{ fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params), std::get<7>(params), std::get<8>(params)); return ReturnType(); }
	};
	template<typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	struct LuaContext::FnTupleWrapper<R (T1,T2,T3,T4,T5,T6,T7,T8,T9)> {
		typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9>	ParamsType;
		typedef typename LuaContext::Tupleizer<R>::type	ReturnType;
		static ReturnType call(std::function<R (T1,T2,T3,T4,T5,T6,T7,T8,T9)> fn, const ParamsType& params)		{ return ReturnType(fn(std::get<0>(params), std::get<1>(params), std::get<2>(params), std::get<3>(params), std::get<4>(params), std::get<5>(params), std::get<6>(params), std::get<7>(params), std::get<8>(params))); }
	};


	// this structure takes a member function pointer and returns its base type
	// typically used on a functor T, like: std::function<RemoveMemberPtr<decltype(&T::operator())>::type>
	template<typename R, typename T>
	struct LuaContext::RemoveMemberPtr<R (T::*)()>								{ typedef R (type)(); };
	template<typename R, typename T>
	struct LuaContext::RemoveMemberPtr<R (T::*)() const>						{ typedef R (type)(); };
	template<typename R, typename T, typename P1>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1)>							{ typedef R (type)(P1); };
	template<typename R, typename T, typename P1>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1) const>						{ typedef R (type)(P1); };
	template<typename R, typename T, typename P1, typename P2>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2)>							{ typedef R (type)(P1,P2); };
	template<typename R, typename T, typename P1, typename P2>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2) const>					{ typedef R (type)(P1,P2); };
	template<typename R, typename T, typename P1, typename P2, typename P3>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3)>						{ typedef R (type)(P1,P2,P3); };
	template<typename R, typename T, typename P1, typename P2, typename P3>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3) const>				{ typedef R (type)(P1,P2,P3); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4)>					{ typedef R (type)(P1,P2,P3,P4); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4) const>				{ typedef R (type)(P1,P2,P3,P4); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4, typename P5>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4,P5)>				{ typedef R (type)(P1,P2,P3,P4,P5); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4, typename P5>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4,P5) const>			{ typedef R (type)(P1,P2,P3,P4,P5); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4,P5,P6)>				{ typedef R (type)(P1,P2,P3,P4,P5,P6); };
	template<typename R, typename T, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
	struct LuaContext::RemoveMemberPtr<R (T::*)(P1,P2,P3,P4,P5,P6) const>		{ typedef R (type)(P1,P2,P3,P4,P5,P6); };


	// this structure takes a template parameter T
	// if T is a tuple, it returns T ; if T is not a tuple, it returns std::tuple<T>
	// you have to use this structure because std::tuple<std::tuple<...>> triggers a bug in both MSVC++ and GCC
	template<typename T> struct LuaContext::Tupleizer						{ typedef std::tuple<T> type; };
	template<> struct LuaContext::Tupleizer<void>							{ typedef std::tuple<> type; };
	template<> struct LuaContext::Tupleizer<std::tuple<>>					{ typedef std::tuple<> type; };
	template<typename T1>
	struct LuaContext::Tupleizer<std::tuple<T1>>							{ typedef std::tuple<T1> type; };
	template<typename T1, typename T2>
	struct LuaContext::Tupleizer<std::tuple<T1,T2>>							{ typedef std::tuple<T1,T2> type; };
	template<typename T1, typename T2, typename T3>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3>>						{ typedef std::tuple<T1,T2,T3> type; };
	template<typename T1, typename T2, typename T3, typename T4>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4>>					{ typedef std::tuple<T1,T2,T3,T4> type; };
	template<typename T1, typename T2, typename T3, typename T4, typename T5>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4,T5>>				{ typedef std::tuple<T1,T2,T3,T4,T5> type; };
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4,T5,T6>>				{ typedef std::tuple<T1,T2,T3,T4,T5,T6> type; };
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4,T5,T6,T7>>			{ typedef std::tuple<T1,T2,T3,T4,T5,T6,T7> type; };
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4,T5,T6,T7,T8>>		{ typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8> type; };
	template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
	struct LuaContext::Tupleizer<std::tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9>>	{ typedef std::tuple<T1,T2,T3,T4,T5,T6,T7,T8,T9> type; };
	
}


#endif
